
public class HashTable {
	private int[] table;

	

	/*
	 * A method that adds a new Key on the HashTable. This method contains two
	 * integer variables that plays a vital role in storing the possible indexes
	 * where the inserted key will be stored. The first integer variable hash,
	 * stores the original index for the key after undertaking the HashFunction but
	 * if the index is already taken the probingIndex will be the index used since
	 * it contains or may contain the available index for the key to be stored after
	 * performing linear probing.
	 */
	public void add(int key) {
		int hash = HashFunction(key);
		int probingIndex = (hash + 1);
		System.out.println("Original Index: " + hash);

		/*
		 * Adds a new hash on the HashTable using Linear Probing. If the element of the
		 * array which has an index that has the same value as the hash contains a value
		 * of negative one, which means its unoccupied, the hash will be inserted on
		 * that element. Else if the element of the array which has an index that has
		 * the same value as the hash contains a value greater than negative one, which
		 * means that the index was occupied by an another hash, the hash that will be
		 * inserted will then occupy the next nearest element that contains a zero
		 * value. After reaching the end of the array and still is unsuccessful to find
		 * an unoccupied element, the program will then go back at the top of the array
		 * and will still search for an element. But if the hash is still unsuccessful
		 * to find an unoccupied element, an error message will be displayed and the
		 * user will be returned to the Menu.
		 */
		if (table[hash] != 0) {

			while (true) {
				if (table[probingIndex] == 0) {
					hash = probingIndex;
					System.out.println("New Index: " + hash + "\n");
					table[hash] = key;
					System.out.println("New key added successfully!");
					break;
				}

				probingIndex = probingIndex != (table.length - 1) ? probingIndex + 1 : 0;

				if (probingIndex == hash) {
					System.out.println("The hash table is full! Add New Key unsuccessful.");
					break;
				}
			}

		} else {
			table[hash] = key;
			System.out.println("New key added successfully!");
		}

	}

	/*
	 * A method that displays the HashTable using a for loop by displaying each
	 * value of the element of the array. This method displays both the index and
	 * the value that the HashTable contains. Unoccupied indexes are also displayed
	 * by this method.
	 */
	public void view() {
		for (int i = 0; i < table.length; i++)
			System.out.println("Index : " + i + " Key : " + (table[i] == -1 ? "Empty" : table[i]));

	}

	/*
	 * A method that searches a Key on the HashTable. This method also utilize
	 * linear probing just like the add method where they contain two variables
	 * which are the variable that gold the original and expected index and the
	 * variable that contains the index which the key was stored due to linear
	 * probing.
	 */
	public void search(int key) {
		int hash = HashFunction(key);
		int probingIndex = (hash + 1);

		/*
		 * If the desired-to-search key is on the element of the array that has an index
		 * that has the same value as the hash of the key, the program will then display
		 * the key and also the index of the key on the array. Else if the
		 * desired-to-search key is not on the element of the array that has an index
		 * that has the same value as the hash of the key, the program will then find
		 * the desired-to-search key on the other elements of the HashTable and display
		 * it alongside its new index. After reaching the end of the array, the program
		 * will now search from the top of the HashTable. But if the program is still
		 * unsuccessful to find the desired-to-search key, an error message will be
		 * displayed and the user will be returned to the Menu.
		 */
		if (table[hash] != key) {
			while (true) {
				if (table[probingIndex] == key) {
					hash = probingIndex;
					System.out.println(" Index : " + hash + "Key : " + key);
					break;
				}

				probingIndex = probingIndex != (table.length - 1) ? probingIndex + 1 : 0;

				if (probingIndex == hash) {
					System.out.println("The key is non-existent in the hashtable.");
					break;
				}
			}
		} else {
			System.out.println("Key : " + key + " Index : " + hash);
		}
	}

	/*
	 * A method that deletes a Key on the HashTable. Linear probing is also used in
	 * this method where the index of the key that is desired to be deleted will be
	 * searched if the index of the key after being hashed is already taken by a
	 * different key.
	 */
	public void delete(int key) {
		int hash = HashFunction(key);
		int probingIndex = (hash + 1);

		/*
		 * If the desired-to-delete key is on the element of the array that has an index
		 * that has the same value as the hash of the key, the program will then remove
		 * the key on the HashTable and will be replace by a dummy value, which is -1.
		 * Else if the desired-to-delete key is not on the element of the array that has
		 * an index that has the same value as the hash of the key, the program will
		 * then find the desired-to-delete key on the other elements of the HashTable
		 * and delete it. After reaching the end of the array, the program will now
		 * search from the top of the HashTable. But if the program is still
		 * unsuccessful to find the desired-to-delete key, an error message will be
		 * displayed and the user will be returned to the Menu.
		 */
		if (table[hash] != key) {
			while (true) {
				if (table[probingIndex] == key) {
					hash = probingIndex;
					table[hash] = 0;
					System.out.println("Key deleted successfully!");
					break;
				}

				probingIndex = probingIndex != (table.length - 1) ? probingIndex + 1 : 0;

				if (probingIndex == hash) {
					System.out.println("The key is non-existent in the hashtable.");
					break;
				}
			}
		} else {
			table[hash] = -1;
			System.out.println("Key deleted successfully!");
		}
	}

	/*
	 * A method for Hashing using the division method, which takes the entered key
	 * of the user and modulo dividing it to 20. Then the remainder of the division
	 * will be returned as a hash.
	 */
	private static int HashFunction(int key) {
		int hash = key % 20;
		return hash;
	}
}
